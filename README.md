# :pushpin: Java로 테니스 계수기 만들기 

> Java의 interface 개념을 활용한 테니스 계수기 구현과 파일 출력기능  
> https://go-quality.dev  

</br> 

### 목차

<details>
<summary><b>목차 펼치기</b></summary>
<div markdown="1">

1. 제작기간 & 참여 인원  <br>

2. 사용 기술  <br>

3. 요구 분석    <br>

4. 순서도 (프로그램 흐름)  <br>

5. 클래스 다이어그램 (부제: Interface의 개념과 특징)  <br>

6. 핵심 기능 코딩 <br>

7. 트러블 슈팅  <br>

8. 프로젝트 회고 <br>

   <br> 


## 1. 제작 기간 & 참여 인원 

👩‍👧‍👧 팀 프로젝트 (7인)<br>

-  2023 3월 7일 ~ 3월 10일 (4일)  <br>

</br>



## 2. 사용 기술  

- Java 8 사용  <br>
- 툴 : eclipse 사용   <br>

</br>



## 3. 요구 분석 

① 두 선수 중 득점한 선수의 게임 포인트를 증가시킨다. 득점할 때마다 득점 포인트는 0→15→30→40 순으로 표현한다.  <br>
② 게임 점수가 40인 선수가 포인트를 획득하면 그 게임을 승리한다. 단, 두 선수가 모두 40점인 경우는 듀스가 된다. 듀스가 된 후에는 상대방보다 두 포인트를 더 획득한 선수가 그 게임을 승리한다.  <br>
③ 상대방보다 2게임 이상 차이를 두고 6게임 이상을 먼저 획득한 선수가 그 세트를 승리한다.   <br>
④ 경기 세트 수의 반 이상을 먼저 승리한 선수가 최종 승자이다.  <br> <br>

👏 정리하면,  <br>
포인트 > 게임 > 세트 > 매치 (게임종료)   <br>

1. 포인트  <br>
   0(0점) > 15(1점) > 30(2점) > 40(3점)  <br>
   => 40점(3점)인 선수가 한번더 득점시 (4포인트 획득 시) 1게임 획득   <br>

 ✔  듀스 : 40:40 > 어드벤티지룰 : 두포인트 더 획득시 한게임 획득   <br>

2. 게임<br>
   6 게임 승리시 한세트 획득  <br>

✔ 듀스 : 5:5 > 어드벤티지룰 : 두 게임 연속으로 이겨야 한 세트 획득   <br>
✔ 테이브레이크 : 6:6이 되면 2 게임을 더 얻는 방식 (고려 X)  <br>

3. 세트 

* 여성 단식/ 복식 / 혼합복식 : 3세트 => 2세트 획득시 매치(승리)  <br>

* 남성 단식/ 복식 : 5세트 => 3세트 획득시 매치(승리) <br><br>

  

## 4. 순서도 (프로그램 흐름) 



​	이 서비스의 핵심 기능은 포인트를 획득해 전체적인 경기 점수에 반영하는 계수기 기능과 현재 게임 스코어를 출력하는 점수판 기능이다. 사용자는 경기수와 경기자를 설정하고 실행을 하면 반복적으로 승자를 도출하며 테니스 경기를 자동으로 실행하고 경기 종료시 파일에 그 결과를 출력한다.


​	이 단순한 기능의 흐름을 보면, 서비스가 어떻게 동작하는지 알 수 있다.  



![프로그램 순서도](D:\Programming\images\readme\프로그램 순서도.jpg)



## 5. 클래스 다이어그램 설계



<details>
<summary><b>핵심 기능 설명 펼치기</b></summary>
<div markdown="1">

### 5.1. Interface 개념 및 특징

​	인터페이스(interface)란 미완성 설계도, 즉 추상 클래스와 유사하지만 일반 메서드도 포함할 수 있는 다른 일반 추상 클래스와 달리 오로지 추상 메서드와 상수로만 이루어진다 (※ jdk 1.8 버전부턴 'default method' 형태로 포함 가능). 즉 해당 interface 안에는 오로지 메서드의 선언부만 작성된다.

​	이러한 인터페이스의 특징은 다음과 같다. 

1. 다형성 : 조상 타입, 즉 추상 클래스 타입 참조변수로 구현된 자손 인스턴스를 대입하여 사용할 수 있다. 

2. 강제성: 해당 기능을 사용하기 위해  자손 클래스은 필요한 메서드를 강제로 오버라이딩 하게한다. 
3. has-a: 다중 상속, 즉 하나의 조상클래스만 가질 수 있는 것과 달리 여러개의 interface를 상속받을 수 있다 ('기능'으로서의 역할)

​	위와 같은 interface의 개념과 특징을 활용해, 우리가 활용한 인터페이스의 활용방안은 다음 두가지이다. 

1. 기본 설계도
2. 협업  



### 5.2. 클래스 다이어그램 

##### 2023-03

![클래스 다이어그램](D:\Programming\images\readme\클래스 다이어그램.jpg)



​	팀 프로젝트 당시 사용한 인터페이스의 첫번째 사용용도는 '기본 설계도'로서의 인터페이스이다.세상에 많은 계수기들이 있지만, 계수기라면 구현해야할 필수적인 기능인 '점수 계산' 기능과 '점수 출력'기능을 반드시 구현하도록 '계수기'의 기본 설계도를 만들어 계수기라면 반드시 포함해야할 최소한의 메서드를 작성해 놓는다. 하지만 세상엔 수많은 경기 종목이 있고 이 모두를 하나의 클래스에서 다 고려할 수 없기때문에 자손 클래스에서 이를 상속받아 각 경기 종목에 맞춰 각자 알아서 구현하게끔 하는 인터페이스의 형식을 만들어 기본 설계도로서 기능하게 한다. 그래서 이를 상속받은 테니스 계수기, 즉 ScoreCounter도 해당 메서드를 상속받아 테니스 규칙을 적용하면서 자손 메서드를 구현한다. 

​	따라서 우린 기본적인 계수기 기능 메서드를 선언해둔 '계수기' 기본 설계도 인터페이스, 즉 I를 선언하고 테니스 계수기인 ScoreCounter 클래스에서 이를 구현하도록 설정하여 ScoreCounter는 해당 두 메서드를 오버라이딩한다. 이렇게 구현한 ScoreCounter를 실제 경기가 실행되는 main함수가 존재하는 TennisMain 에서 객체 생성해 사용하게끔 구조를 설정했다.  





## 6. 핵심 기능

<details>
<summary><b>핵심 기능 설명 펼치기</b></summary>
<div markdown="1">
### 4.1. 전체 흐름

![핵심기능](D:\Programming\images\README\핵심기능-1689332910364-1.png)

* Class TennisMain : 테니스 경기수 , 경기할 플레이어 등 경기를 세팅해 해당 정보로 계수기 객체를 생성하고 반복문으로 득점자를 도출해 생성해준 계수기 객체에 반영하는 실제 경기 실행 클래스 <br>
* Class ScoreCounter: 테니스의 전반적인 규칙을 반영한 클래스. 크게 점수를 계산하는 계수기 기능과 점수를 출력하는 점수판 기능으로 이루어져 있다. <br>
* Class WriteResult : 최종적인 경기결과를 파일에 출력해주는 출력기능 클래스 <br>



### 4.2. 게임 세팅 및 진행 



![TennisMain](D:\Programming\images\README\TennisMain.png)



- **게임 세팅** :pushpin: [코드 확인](https://github.com/Integerous/goQuality/blob/b587bbff4dce02e3bec4f4787151a9b6fa326319/frontend/src/components/PostInput.vue#L67)

  - 실행할 경기가 남자경기, 여자경기인지 입력받는다. 남자경기는 5세트, 여자경기는 3세트로 세트수가 설정된다.   
  - 각 플레이어의 이름을 입력받은 후 세팅정보를 바탕으로 계수기 객체를 생성한다.

- **게임 진행** :pushpin: [코드 확인]()

  - 1 또는 2로 랜덤하게 득점자를 도출하고, 생성한 계수기 객체에서 포인트를 올리는 pointWinner(), 득점 처리하는  scoreBoard(), 반영된 점수를 출력하는 dispScoreBoard()를 호출한다.
  - 해당 과정을 경기가 끝날때까지 while문으로 반복한다. 
  
  

### 4.3. 계수기 기능 

![scoreBoard](D:\Programming\images\README\scoreBoard.png)

- **득점 처리** :pushpin: [코드 확인](https://github.com/Integerous/goQuality/blob/b2c5e60761b6308f14eebe98ccdb1949de6c4b99/src/main/java/goQuality/integerous/controller/PostRestController.java#L55)

  - 득점자의 포인트를 올리고 테니스 경기 규칙에 따라 포인트, 게임, 세트 수 생성한 객체의 멤버변수에 반영한다. 

  - 포인트 4점 획득시 1게임을, 6게임 획득시 1 Set를 획득한 것으로 필드를 초기화며 게임, 세트 획득시 포인트 및 게임 필드를 리셋한다. 

  - 세트수의 과반수 이상 취득?시 경기를 종료하고 승리자를 도출한다. 

    

- **듀스 게임** :pushpin: [코드 확인]()

  - 한 플레이어가 포인트 4점 획득했는데 1점차면 포인트 듀스가, 6게임 획득했는데 1 게임차면 각각 포인트 듀스, 게임 듀스가 발생한다.

  - 그 즉시 별개의 포인트 필드와 while문을 사용해 듀스게임을 실행한다. 
  
    
  

### 4.4. 점수판 기능 - dispScoreBoard() 

![dispScoreBoard](D:\Programming\images\README\dispScoreBoard.png)

- **경기현황 출력** :pushpin: [코드 확인]()

  - 현재 점수 현황, 즉 점수판을, 즉 두 선수의 포인트, 게임, 세트 획득 현황을 호출시 출력한다.

  - winner 필드가 null이 아니게 될 때 경기 종료 멘트와 함께 승자 정보를 출력한다. 

    

- **승자 정보 출력** :pushpin: [코드 확인]()

  - 현재 점수 현황, 즉 점수판을, 즉 두 선수의 포인트, 게임, 세트 획득 현황을 호출시 출력한다.

  - winner 필드가 null이 아니게 될 때 경기 종료 멘트와 함께 승자 정보를 출력한다. 

  

  


### 4.5. 최종결과 저장- writeTennisResult() 

![WriteResult](D:\Programming\images\README\WriteResult.png)

- **파일 출력** :pushpin: [코드 확인]()
  - 계수기 클래스 (ScoreCounter)에서 winner 필드가 null 이 아니면 파일 출력할 텍스트를 넘겨줍니다. 이때 formating의 편의를 위해 여러 list 변수로 텍스트를 받아둔다. 
  - FileOutputStream을 통해 출력할 file을 지정하고, ObjectOutputStream의 writeUTF() 를 통해 tennisResult.txt에 실제로 출력한다. 

</div>
</details>

</br>

## 5. 핵심 트러블 슈팅

### 5.1. 인터페이스 참조변수 활용 

![그림1](D:\Programming\images\README\그림1.png)

##### 2023-07



![](D:\Programming\images\readme\클래스다이어그램.jpg)



*  인터페이스 특징 중 '다형성'을 활용해 개발 파트를 분리하고자 함.  실행할 떄 어떤 객체가 필요해 이를 생성하거나 상속받아 사용한다고 가정하면 해당 클래스가 개발을 마칠때까지 기다려야 main에서 해당 객체를 사용할 수 있다. 이때 interface를 사용한다면 실제 경기를 진행하는 ClassMain에선 해당 interface의 참조변수를 통해 빈 껍데기 뿐인 메서드지만 사용하고, 다른 사람들은 해당 interface를 상속받은 클래스에서 계수기 메서드를 구현한다. 개발을 마친 후 interface의 참조변수, 즉 조상 참조변수에 해당 자손 클래스 인스턴스를 대입해줌으로서 분업을 용이하게 사용한다. 생성해 포인트를 올리는 계수기 기능 메서드와 점수를 출력하는 점수판 기능의 메서드를 선언하여 실제 경기를 진행하는 ClassMain에서 해당 메서드를 실행할 수 있고 Class ScoreCounter에선 해당 인터페이스의 메서드를 구현하는 방식으로 역할분담을 해서 실제로 기능을 명확히 정해놓으니 계수기 객체가 다 구현이 안되었더라도 실행부 개발과 구현부 개발을 동시에 진행할 수 있었다.  <br>

- 계수기 메서드, 즉 scoreBoard() 함수를 구현할 때 계산의 편의 및 게임, 세트수 계산과의 로직 일치를 위해 포인트 점수를 0,1,2,3 점으로 두어 득점처리를 했습니다. 던 포인트 점수를 테니스 경기 규칙에 맞춰 0, 15, 30, 40 로 각각 변환한다. 

  

### 5.2. 테니스 규칙에 맞는 포인트 출력

- 계수기 메서드, 즉 scoreBoard() 함수를 구현할 때 계산의 편의 및 게임, 세트수 계산과의 로직 일치를 위해 포인트 점수를 0,1,2,3 점으로 두어 득점처리를 했습니다. 던 포인트 점수를 테니스 경기 규칙에 맞춰 0, 15, 30, 40 로 각각 변환한다. 
  
- 하지만 점수판 메서드, dispScoreBoard()를 구현할 때 포인트 점수를 출력할땐 테니스 경기 규칙에 따라 0,15,30,40 점으로 출력을 해야했고, 이 점수들은 서로 불규칙하며 이미 듀스게임까지 고려해놓은 계수기 메서드 로직을 수정할 시간이 부족했습니다.
  
- 그래서 해당 득점처리방식은 그대로 두되, 출력하는 점수판 메서드에서 0,15, 30, 45를 포인트 점수 배열로 만들고, 0,1,2,3을 배열의 index로 활용하여 각각 매칭 시켜 변환하여 출력형식을 바꾸어줍니다.

- 계산의 편의로 0,1,2,3 점으로 두었던 포인트 점수를 테니스 경기 규칙에 맞춰 0, 15, 30, 45 로 각각 변환합니다.

- 이렇게 하니 득점처리는 득점처리대로 로직을 유지하고 계산을 편하게 할 수 있고 출력하기 전에만 그 형식만 일치시켜 바꿔주면되어 편리했습니다

<details>
<summary><b>기존 코드</b></summary>
<div markdown="1">
~~~java

~~~

</div>
</details>

- 이 때 듀스게임까지 가게될 경우 포인트가 4를 넘을 수 있기때문에 단순히 1,2,3을 매칭시켜주면 안되고 5점,6점 같은것도 15점. 30점으로 맞춰줘야하기 때문에 나머지를 활용해 구현했습니다.
- 아래 **개선된 코드**와 같이 QueryDSL을 사용하여 다소 복잡한 Query를 작성하면서도 페이징 처리를 할 수 있었습니다.

<details>
<summary><b>개선된 코드</b></summary>
<div markdown="1">
~~~java
	int[] player1Points = { 0, 15, 30, 40 }; //포인트 점수
		int[] player2Points = { 0, 15, 30, 40 };
		int printplayer1Point 
			= player1Points[player1Point % 4];
		int printplayer2Point 
			= player2Points[player2Point % 4];
~~~

</div>
</details>

</br>

### 5.3. 듀스게임 현황 출력 

- 계수기 메서드, 즉 scoreBoard() 함수를 구현할 때 계산의 편의 및 게임, 세트수 계산과의 로직 일치를 위해 포인트 점수를 0,1,2,3 점으로 두어 득점처리를 했습니다. 던 포인트 점수를 테니스 경기 규칙에 맞춰 0, 15, 30, 40 로 각각 변환합니다. 

- 하지만 점수판 메서드, dispScoreBoard()를 구현할 때 포인트 점수를 출력할땐 테니스 경기 규칙에 따라 0,15,30,40 점으로 출력을 해야했고, 이 점수들은 서로 불규칙하며 이미 듀스게임까지 고려해놓은 계수기 메서드 로직을 수정할 시간이 부족했습니다.

- 그래서 해당 득점처리방식은 그대로 두되, 출력하는 점수판 메서드에서 0,15, 30, 45를 포인트 점수 배열로 만들고, 0,1,2,3을 배열의 index로 활용하여 각각 매칭 시켜 변환하여 출력형식을 바꾸어줍니다.

- 계산의 편의로 0,1,2,3 점으로 두었던 포인트 점수를 테니스 경기 규칙에 맞춰 0, 15, 30, 45 로 각각 변환합니다.

- 이렇게 하니 득점처리는 득점처리대로 로직을 유지하고 계산을 편하게 할 수 있고 출력하기 전에만 그 형식만 일치시켜 바꿔주면되어 편리했습니다

<details>
<summary><b>기존 코드</b></summary>
<div markdown="1">

~~~java

~~~

</div>
</details>

- 이 때 듀스게임까지 가게될 경우 포인트가 4를 넘을 수 있기때문에 단순히 1,2,3을 매칭시켜주면 안되고 5점,6점 같은것도 15점. 30점으로 맞춰줘야하기 때문에 나머지를 활용해 구현했습니다.
- 아래 **개선된 코드**와 같이 QueryDSL을 사용하여 다소 복잡한 Query를 작성하면서도 페이징 처리를 할 수 있었습니다.

<details>
<summary><b>개선된 코드</b></summary>
<div markdown="1">

~~~java
int[] player1Points = { 0, 15, 30, 40 }; //포인트 점수
int[] player2Points = { 0, 15, 30, 40 };

int printplayer1Point 
		= player1Points[player1Point % 4];
int printplayer2Point 
		= player2Points[player2Point % 4];
~~~

</div>
</details>

</br>



## 6. 회고 / 느낀점

>프로젝트 개발 회고 글: https://zuminternet.github.io/ZUM-Pilot-integer/
